import requests, json, os, sys, base64, time, cgi
from collections import OrderedDict
import plotly.plotly as py
import plotly.exceptions
from plotly.graph_objs import *  # for exec statements
import plotly.utils as utils
from exceptions import OSError


####### assumptions #######
# 1. config.json MUST exist

## function definitions ##

## main ##

    ## compile all examples ##

        ## for each, read config.json ##

            ## record directions from that for later... ##

    ## filter out unwanted examples (filter by folders now?) ##

### auto-generated file stuff ###
auto_dir = 'auto-docs'  # where we keep any autogenerated content
doc_dir = os.path.join(auto_dir, 'api')  # the main page for all documentation
exceptions_dir = 'exceptions'
pre_book_file = 'pre-book.json'

### hard-coded file stuff ###
hard_coded_dir = 'hard-coded'
config_file = 'config.json'
model_file = 'model.json'
url_file = 'url.json'
image_file = 'image.png'

### sign in stuff ###
users = dict(
    tester=dict(un="theengineear", ak="o9zlr0hy6z"),
    julia=dict(un="theengineear", ak="o9zlr0hy6z"),
    matlab=dict(un="theengineear", ak="o9zlr0hy6z"),
    python=dict(un="theengineear", ak="o9zlr0hy6z"),
    r=dict(un="theengineear", ak="o9zlr0hy6z"),
    node=dict(un="theengineear", ak="o9zlr0hy6z")

    # tester=dict(un="test-runner", ak="9h29fe3l0x"),
    # julia=dict(un='JuliaAPI', ak='3bule2whyg'),
    # matlab=dict(un='MATLABAPI', ak='jzt0hr6tzv'),
    # python=dict(un="PythonAPI", ak="ubpiol2cve"),
    # r=dict(un='rAPI', ak='yu680v5eii'),
    # node=dict(un='nodeAPI', ak='1eobtyua4l')
)

py.sign_in(users['tester']['un'], users['tester']['ak'])

### server stuff ###
translator_server = "https://plot.ly/translate_figure/"
image_server = "https://plot.ly/apigenimage/"  # to be: "https://plot.ly/image/"

### style stuff ###
lines_between_sections = 2

section_config_requirements = dict(
    name=basestring,
    # relative_url=basestring,
    has_thumbnail=bool
)

example_config_requirements = dict(
    name=basestring,
    languages=dict
)

commands = ['code', 'urls', 'images', 'clean', 'execs']

languages = ['python', 'matlab', 'r', 'julia', 'node', 'json']

### define extensions for executable code ###
lang_to_ext = dict(python='py', julia='jl', matlab='m', r='r', node='js')
ext_to_lang = dict(py='python', jl='julia', m='matlab', r='r', js='node')

### define imports ###
imports = dict(
    python="import plotly.plotly as py\nfrom plotly.graph_objs import *",
    matlab="",
    r="library(plotly)",
    julia="using Plotly",
    node=""
)

### define sign in ###
sign_in = {
    'documentation': dict(
        python=
            "py.sign_in({{% if username %}}\"{{{{username}}}}\""
            "{{% else %}}'{un}'{{% endif %}}, "
            "{{% if api_key %}}\"{{{{api_key}}}}\""
            "{{% else %}}'{ak}'{{% endif %}})".format(**users['python']),
        matlab=
            "signin({{% if username %}}'{{{{username}}}}'"
            "{{% else %}}'{un}'{{% endif %}}, "
            "{{% if api_key %}}'{{{{api_key}}}}'"
            "{{% else %}}'{ak}'{{% endif %}})".format(**users['matlab']),
        r=
            "p <- plotly(username={{% if username %}}\"{{{{username}}}}\""
            "{{% else %}}'{un}'{{% endif %}}, "
            "key={{% if api_key %}}\"{{{{api_key}}}}\""
            "{{% else %}}'{ak}'{{% endif %}})".format(**users['r']),
        julia=
            "Plotly.signin({{% if username %}}\"{{{{username}}}}\""
            "{{% else %}}\"{un}\"{{% endif %}}, "
            "{{% if api_key %}}\"{{{{api_key}}}}\""
            "{{% else %}}\"{ak}\"{{% endif %}})".format(**users['julia']),
        node=
            "var plotly = require('plotly')("
            "{{% if username %}}'{{{{username}}}}'"
            "{{% else %}}'{un}'{{% endif %}},"
            "{{% if api_key %}}'{{{{api_key}}}}'"
            "{{% else %}}'{ak}'{{% endif %}});".format(**users['node'])
    ),
    'execution': dict(
        python="py.sign_in('{un}', '{ak}')".format(**users['tester']),
        matlab="signin('{un}', '{ak}')".format(**users['tester']),
        r="p <- plotly(username='{un}', key='{ak}')".format(**users['tester']),
        julia='using Plotly\nPlotly.signin("{un}", "{ak}")'
              ''.format(**users['tester']),
        node="var plotly = require('plotly')('{un}', '{ak}')"
             "".format(**users['tester'])
    )
}


def get_command_list():
    try:
        arg1 = sys.argv[1]
        command_list = arg1.split('+')
        for command in command_list:
            if command not in commands:
                raise Exception()
    except:
        command_list = None
    if not command_list:
        print "usage:\n"\
              "python run.py command examplename\n"\
              "python run.py command\n",\
              "python run.py command1+command2+command3 examplename\n"\
              "python run.py command1+command2+command3\n"
        print 'commands:', commands
        sys.exit(0)
    else:
        return command_list


def get_keepers():
    keepers = []
    while len(sys.argv) > 2:
        keepers += [sys.argv.pop()]
    return keepers


def clean():
    """removes ENTIRE doc_dir directory, careful!"""
    def clean_directory(directory):
        for name in os.listdir(directory):
            full_name = os.path.join(directory, name)
            if os.path.isdir(full_name):
                clean_directory(full_name)
                os.rmdir(full_name)
            else:
                os.remove(full_name)
    if os.path.exists(auto_dir):
        clean_directory(auto_dir)
    if os.path.exists(exceptions_dir):
        clean_directory(exceptions_dir)
    if os.path.exists(pre_book_file):
        os.remove(pre_book_file)


def write_pre_book(section_dir, keepers=None):
    """
    1. for each directory, if there are sub-directories: recurse
    2. if no sub-directories, and name in keepers, keep!
    """
    section_dict = dict()
    section_dict['path'] = section_dir
    section_dict['name'] = section_dir.split(os.path.sep)[-1]
    section_dict[config_file] = os.path.join(section_dir, config_file)
    subsections = [child for child in os.listdir(section_dir)
                   if os.path.isdir(os.path.join(section_dir, child))]
    if subsections:
        subsections_dict = dict()
        for subsection in subsections:
            subsection_dir = os.path.join(section_dir, subsection)
            subsection_dict = write_pre_book(subsection_dir, keepers)
            if subsection_dict:
                subsections_dict[subsection] = subsection_dict
        if subsections_dict:
            section_dict['subsections'] = subsections_dict
    else:
        if keepers:
            name = "-".join(section_dict['path'].split(os.path.sep))
            keep = [True for keeper in keepers if keeper in name]
            if keep:
                file_dict = {f: os.path.join(section_dir, f)
                             for f in os.listdir(section_dir)
                             if f != config_file}
            else:
                file_dict = None
        else:
            file_dict = {f: os.path.join(section_dir, f)
                         for f in os.listdir(section_dir) if f != config_file}
        if file_dict:
            section_dict['files'] = file_dict
    if 'files' in section_dict or 'subsections' in section_dict:
        return section_dict


def load_config_files(section):
    try:
        with open(section[config_file]) as f:
            section[config_file] = json.load(f)
    except ValueError:
        raise ValueError("invalid json in {}".format(section[config_file]))
    if 'subsections' in section:
        validate_config(
            section[config_file], section['path'], section_config_requirements)
        for subsection_name, subsection in section['subsections'].items():
            load_config_files(subsection)
    elif 'files' in section:
        validate_config(
            section[config_file], section['path'], example_config_requirements)


def validate_config(config, path, config_requirements):
    for key, val in config_requirements.items():
        if key not in config:
            raise KeyError(
                "missing key '{}' in {} at location '{}'"
                "".format(key, config_file, path))
        elif not isinstance(config[key], val):
            raise ValueError(
                "wrong value type for key '{}' in {} at location '{}'"
                "".format(key, config_file, path))


def process_pre_book(section, command_list):
    if 'subsections' in section:
        for subsection_name, subsection in section['subsections'].items():
            process_pre_book(subsection, command_list)
    elif 'files' in section:
        if [language for language in section[config_file]['languages']
                if section[config_file]['languages'][language] == 'model']:
            process_model_example(section, command_list)
        if [language for language in section[config_file]['languages']
                if section[config_file]['languages'][language] == 'url']:
            process_url_example(section, command_list)
        if [language for language in section[config_file]['languages']
                if section[config_file]['languages'][language] == 'script']:
            process_script_example(section, command_list)


def process_model_example(example, command_list):
    """
    1. load model.json file
    2. for each language with 'model' as the *source*...
    3. translate model to language with translator
    4. if save image: save image
    5. if save code: save code
    6. if save url: save url
    """
    print "\tprocessing {} in {}".format(model_file, example['path'])
    try:
        with open(example['files'][model_file]) as f:
            model = json.load(f)
    except KeyError:
        raise KeyError(
            "{} required and could not be found in {}"
            "".format(model_file, example['path']))
    except ValueError:
        raise ValueError(
            "{} required and could not be opened in {}"
            "".format(model_file, example['path']))
    for language, source in example[config_file]['languages'].items():
        if source == 'model':
            code = ""
            if 'prepend' in example[config_file] and example[config_file]['prepend']:
                prepend_file = "prepend.{}".format(lang_to_ext[language])
                if prepend_file in example['files']:
                    with open(example['files'][prepend_file]) as f:
                        code += f.read() + "\n"
                else:
                    raise Exception(
                        "couldn't find '{}' in '{}'"
                        "".format(prepend_file, example['path'])
                    )
                # TODO: finish
            data = {'json_figure': model,
                    'language': language,
                    'pretty': True}
            res = requests.get(translator_server, data=json.dumps(data))
            if res.status_code == 200:
                code += res.content  # todo, text?
                code = code.replace("<pre>", "").replace("</pre>", "")
            else:
                print "\t\tskipping '{}', bad response from plotly " \
                      "translator!".format(language)
                continue
            code = code.replace('">>>', "").replace('<<<"', "")
            code = code.replace("'>>>", "").replace("<<<'", "")
            if 'append' in example[config_file] and example[config_file]['append']:
                append_file = "append.{}".format(lang_to_ext[language])
                if append_file in example['files']:
                    with open(example['files'][append_file]) as f:
                        code += f.read() + "\n"
                else:
                    raise Exception(
                        "couldn't find '{}' in '{}'"
                        "".format(append_file, example['path'])
                    )
                # TODO: finish
            if 'code' in command_list:
                code_string = format_code(code, language, example, model)
                example[language] = code_string
            exec_string = format_code(code, language, example, model,
                                      mode='execution')
            example[language+"-exec"] = exec_string
    if 'images' in command_list or 'urls' in command_list:
        if 'python-exec' in example:
            fig, plot_url = exec_python_string(example['python-exec'])
            if 'images' in command_list:
                image = get_image_with_python(fig)
                if image is not None:
                    example[image_file] = image
            if 'urls' in command_list:
                example[url_file] = plot_url


def process_script_example(example, command_list):
    """
    1. for each language with 'model' as the *source*...
    2. load script.ext file
    3. if save image: save image
    4. if save code: save code
    5. if save url: save url
    """
    print "\tprocessing scripts in {}".format(example['path'])
    print "\t\tskipping scripts for now!!!"
    # for language, source in example[config_file]['languages'].items():
    #     if source == 'script':
    #         script = "script.{}".format(lang_to_ext[language])
    #         try:
    #             with open(example['files'][script]) as f:
    #                 content = f.read()
    #         except KeyError:
    #             raise KeyError(
    #                 "{} not found in {}".format(script, example['path']))
    #         example['exec-'+language] = content
    # # TODO: make sure this generates a NEW example (same name)


def process_url_example(example, command_list):
    """
    1. for each language with 'url' as the *source*...
    2. translate model to language with translator
    3. if save image: save image
    4. if save code: save code
    """
    print "\tprocessing {} in {}".format(url_file, example['path'])
    try:
        with open(example['files'][url_file]) as f:
            url = json.load(f)['url']
    except ValueError:
        raise ValueError(
            "{} required and could not be opened in {}"
            "".format(url_file, example['path']))
    except KeyError:
        raise KeyError(
            "{} required and could not be found in {}"
            "".format(url_file, example['path']))
    json_resource = ".".join([url, 'json'])
    res = requests.get(json_resource)
    if res.status_code == 200:
        figure_str = res.content
        figure_str = figure_str.replace("<pre>", "").replace("</pre>", "")
        figure_str = figure_str.replace("<html>", "").replace("</html>", "")
        figure = json.loads(figure_str)
    else:
        print "\t\tskipping '{}', bad response from shareplot_as_code for " \
              ".json".format(example['path'])
        return None
    for language, source in example[config_file]['languages'].items():
        if source == 'url':
            code = ""
            resource = ".".join([url, lang_to_ext[language]])
            res = requests.get(resource)
            if res.status_code == 200:
                code += res.content  # todo, text?
                code = code.replace("<pre>", "").replace("</pre>", "")
                code = code.replace("<html>", "").replace("</html>", "")
            else:
                print "\t\tskipping '{}', bad response from shareplot_as_code"\
                      "".format(language)
                continue
            if 'code' in command_list:
                code_string = format_code(code, language, example, figure)
                example[language] = code_string
            exec_string = format_code(code, language, example, figure,
                                      mode='execution')
            example[language+"-exec"] = exec_string
    if 'images' in command_list or 'urls' in command_list:
        if 'python-exec' in example:
            fig, plot_url = exec_python_string(example['python-exec'])
            if 'images' in command_list:
                image = get_image_with_python(fig)
                if image is not None:
                    example[image_file] = image
            if 'urls' in command_list:
                example['url'] = plot_url
        else:
            print "\t\tcannot process image with python, this example is only " \
                  "valid for '{}'".format(example[config_file]['languages'])


def get_image_with_python(fig):
    for attempt in range(2):
        try:
            headers = {'plotly-username': users['tester']['un'],
                       'plotly-apikey': users['tester']['ak'],
                       'plotly-version': '2.0',
                       'plotly-platform': 'python'}
            server = image_server
            res = requests.post(
                server,
                data=json.dumps(fig, cls=utils._plotlyJSONEncoder),
                headers=headers
            )
            if res.status_code != 200:
                raise plotly.exceptions.PlotlyError()
            # image = base64.b64decode(json.loads(res.content)['payload'])
            image = json.loads(res.content)['payload']
            return image
        except plotly.exceptions.PlotlyError:
            time.sleep(10)
            if attempt == 1:
                print "\t\timage could not be saved, check the " \
                      "following figure object:\n\n{}\n"


def exec_python_string(exec_string):
    """save image to directory by executing python code-string and saving
    """
    fig, plot_url = None, None
    try:
        exec exec_string
    except:
        print exec_string
        raise
    if not plot_url:
        raise Exception("'plot_url' not found in exec string!")
    if not fig:
        raise Exception("no 'fig' object found in exec string!")
    return fig, plot_url


def format_code(body_string, language, example, figure, mode='documentation'):
    file_import = imports[language]
    file_sign_in = sign_in[mode][language]
    if mode == 'execution':
        reformatting_code = get_reformatting_code(language)
    else:
        reformatting_code = ""
    plot_call = get_plot_call(language, figure, example, mode=mode)
    sections = [file_import,
                file_sign_in,
                body_string,
                reformatting_code,
                plot_call]
    sections = [sec for sec in sections if sec]
    code_string = ("\n" * lines_between_sections).join(sections)
    if mode == 'documentation':
        code_string = cgi.escape(code_string)
    return code_string


def get_reformatting_code(language):
    reformatting_code = ""
    if language == 'python':
        reformatting_code = (
            "if not fig:\n"
            "    if not data:\n"
            "        raise Exception('no data OR figure!!')\n"
            "    fig = dict(data=data)  # assumes fig or data\n"
            "if 'layout' not in fig:\n"
            "    fig['layout'] = dict()\n"
            "if 'margin' not in fig['layout']:\n"
            "    fig['layout']['margin'] = dict(t=50, b=50, r=50, l=50)\n"
            "fig['layout'].update(autosize=False, width=500, height=500)\n"
        )
    return reformatting_code


def get_plot_call(language, figure, example, mode):
    """define strings for actual plot calls"""
    tf_dict = {
        True: dict(
            python='True',
            matlab='true',
            julia='true',
            r='TRUE',
            node='true'
        ),
        False: dict(
            python='False',
            matlab='false',
            julia='false',
            r='FALSE',
            node='false'
        )
    }
    name_list = example['path'].split(os.path.sep)[-2:]  # TODO this may break!
    filename = "-".join(name_list)
    try:
        plot_options = example[config_file]['plot-options']
    except KeyError:
        plot_options = {}
    if mode == 'execution':
        plot_options['auto_open'] = False
    if language == 'python':
        string = "plot_url = py.plot("
        if 'layout' in figure:
            string += 'fig, '
        else:
            string += 'data, '
        string += "filename='{}'".format(filename)
        if plot_options:
            for key, val in plot_options.items():
                try:
                    string += ", {}={}".format(key, tf_dict[val][language])
                except KeyError:
                    string += ", {}={}".format(key, val)
        return string + ")"
    elif language == 'matlab':
        string = "response = plotly(data, struct("
        if 'layout' in figure:
            string += "'layout', layout, "
        string += "'filename', '{}'".format(filename)
        string += ", 'fileopt', 'overwrite'"
        if plot_options:
            for key, val in plot_options.items():
                try:
                    string += ", '{}', '{}'".format(key, tf_dict[val][language])
                except KeyError:
                    string += ", '{}', '{}'".format(key, val)
        string += "));"
        string += "\nplot_url = response.url"
        return string
    elif language == 'julia':
        string = "response = Plotly.plot([data], ["
        if 'layout' in figure:
            string += '"layout" => layout, '
        string += '"filename" => "{fn}"'.format(fn=filename)
        string += ', "fileopt" => "overwrite"'
        if plot_options:
            for key, val in plot_options.items():
                try:
                    string += ', "{}" => "{}"'.format(key, tf_dict[val][language])
                except KeyError:
                    string += ', "{}" => "{}"'.format(key, val)
        string += "])"
        string += '\nplot_url = response["url"]'
        return string
    elif language == 'r':
        string = 'response <- p$plotly(data, kwargs=list('
        if 'layout' in figure:
            string += 'layout=layout, '
        string += 'filename="{}"'.format(filename)
        string += ', fileopt="overwrite"'
        if plot_options:
            for key, val in plot_options.items():
                try:
                    string += ', {}="{}"'.format(key, tf_dict[val][language])
                except KeyError:
                    string += ', {}="{}"'.format(key, val)
        string += "))"
        string += '\nurl <- response$url\n'
        string += 'filename <- response$filename'
        return string
    elif language == 'node':
        string = 'var graph_options = {{filename: "{}"'.format(filename)
        string += ', fileopt: "overwrite"'
        if 'layout' in figure:
            string += ', layout: layout'
        if plot_options:
            for key, val in plot_options.items():
                try:
                    string += ', {}: "{}"'.format(key, tf_dict[val][language])
                except KeyError:
                    string += ', {}: "{}"'.format(key, val)
        string += '}'
        string += "\nplotly.plot("
        if 'data' in figure and figure['data']:
            string += "data"
        else:
            string += "[]"
        string += ", graph_options, function (err, msg) {"
        string += "\n    console.log(msg);"
        string += "\n});"
        return string
    else:
        return ''


def make_exceptions_paths(section):
    if 'subsections' in section:
        for subsection_name, subsection in section['subsections'].items():
            make_exceptions_paths(subsection)
    elif 'files' in section and len(section['files']):
        for language, source in section[config_file]['languages'].items():
            executable = "-".join(['exec', language])
            if source == 'script' and executable in section:
                if language != 'python':
                    folder = "-".join(section['path'].split(os.path.sep)[-2:])
                    filename = ".".join(['code', lang_to_ext[language]])
                    path = os.path.join(exceptions_dir, language, folder)
                    try:
                        os.makedirs(path)
                    except OSError:
                        pass
                    with open(os.path.join(path, filename), 'w') as f:
                        f.write(section[executable])


def save_pre_book(pre_book):
    try:
        os.makedirs(doc_dir)
    except OSError:
        pass
    with open(pre_book_file, 'w') as f:
        json.dump(pre_book, f, indent=2)


def main():
    command_list = get_command_list()  # TODO unused...
    keepers = get_keepers()
    print "\n\nrunning with commands: {}\n\n".format(command_list)
    if 'clean' in command_list:
        clean()
        command_list.pop(command_list.index('clean'))
    if command_list:
        print "compiling pre-book"
        pre_book = write_pre_book(hard_coded_dir, keepers)
        # import pprint
        # pp = pprint.PrettyPrinter(indent=1)
        # pp.pprint(pre_book)
        print "validating config files"
        load_config_files(pre_book)
        print "beginning to process the pre_book"
        process_pre_book(pre_book, command_list)
        print "creating paths for exceptional, non-python cases"
        make_exceptions_paths(pre_book)
        print "saving pre_book"
        save_pre_book(pre_book)

if __name__ == "__main__":
    main()